from mindquantum import *
import numpy as np

def test_gate():
    circ = Circuit()
    circ += H.on(0)
    circ += S.on(2)
    circ += T.on(1)
    circ += H.on(1, 2)
    circ += X.on(2)
    circ += UN(H, circ.n_qubits)
    circ += X.on(0, 1)
    circ += UN(H, circ.n_qubits)
    circ += Y.on(1)
    circ += UN(H, circ.n_qubits)
    circ += Y.on(0,1)
    circ += UN(H, circ.n_qubits)
    circ += Z.on(0)
    circ += UN(H, circ.n_qubits)
    circ += Z.on(1,2)
    circ += UN(H, circ.n_qubits)
    circ += S.on(1)
    circ += UN(H, circ.n_qubits)
    circ += S.on(2,0)
    circ += UN(H, circ.n_qubits)
    circ += T.on(2)
    circ += UN(H, circ.n_qubits)
    circ += T.on(0,1)
    circ += UN(H, circ.n_qubits)
    circ += S.hermitian().on(0)
    circ += UN(H, circ.n_qubits)
    circ += S.hermitian().on(1,2)
    circ += UN(H, circ.n_qubits)
    circ += T.hermitian().on(0)
    circ += UN(H, circ.n_qubits)
    circ += T.hermitian().on(1,2)
    circ += UN(H, circ.n_qubits)
    circ += PhaseShift(1).on(0)
    circ += UN(H, circ.n_qubits)
    circ += PhaseShift(1).on(1,2)
    circ += UN(H, circ.n_qubits)
    circ += XX(1).on([0,1])
    circ += UN(H, circ.n_qubits)
    circ += XX(1).on([1,2], 0)
    circ += UN(H, circ.n_qubits)
    circ += YY(1).on([0,1])
    circ += UN(H, circ.n_qubits)
    circ += YY(1).on([1,2], 0)
    circ += UN(H, circ.n_qubits)
    circ += ZZ(1).on([0,1])
    circ += UN(H, circ.n_qubits)
    circ += ZZ(1).on([1,2], 0)
    circ += UN(H, circ.n_qubits)
    circ += SWAP.on([0,1])
    circ += UN(H, circ.n_qubits)
    circ += SWAP.on([1,2], 0)
    circ += UN(H, circ.n_qubits)
    circ += ISWAP.on([1,2])
    circ += UN(H, circ.n_qubits)
    circ += ISWAP.on([1,0], 2)
    circ += UN(H, circ.n_qubits)
    circ += RX(1).on(0)
    circ += UN(H, circ.n_qubits)
    circ += RX(1).on(1,2)
    circ += UN(H, circ.n_qubits)
    circ += RY(1).on(1)
    circ += UN(H, circ.n_qubits)
    circ += RY(1).on(2,0)
    circ += UN(H, circ.n_qubits)
    circ += RZ(1).on(2)
    circ += UN(H, circ.n_qubits)
    circ += RZ(1).on(0, 1)
    
    m_sim = Simulator('mqmatrix', 3)
    m_sim.set_qs(np.array([1,2,3,4, 5, 6, 7, 8]))
    m_sim.apply_circuit(circ)
    qs0 = m_sim.get_qs()
    v_sim = Simulator('mqvector', 3)
    v_sim.set_qs(np.array([1,2,3,4,5, 6, 7, 8]))
    v_sim.apply_circuit(circ)
    vec = v_sim.get_qs()
    qs1 = np.outer(vec, vec.conj())
    # print(qs0)
    # print()
    # print(qs1)
    is_equal = np.allclose(qs0,qs1)
    print('test_gate:', is_equal)
    
def test_measure():
    circ = random_circuit(3,100)
    circ.measure(0)
    circ.measure(1)
    m_sim = Simulator('mqmatrix', 3, seed=42)
    m_sim.set_qs(np.array([1,2,3,4,5,6,7,8]))
    v_sim = Simulator('mqvector', 3, seed=42)
    v_sim.set_qs(np.array([1,2,3,4,5,6,7,8]))
    m_sim.apply_circuit(circ)
    v_sim.apply_circuit(circ)
    qs0 = m_sim.get_qs()
    vec = v_sim.get_qs()
    qs1 = np.outer(vec, vec.conj())
    # print(qs0)
    # print(qs1)
    is_equal = np.allclose(qs0,qs1)
    print('test_measure:', is_equal)
    
def test_sampling():
    circ = random_circuit(3,100)
    circ.measure(0)
    circ.measure(1)
    m_sim = Simulator('mqmatrix', 3, seed=42)
    m_sim.set_qs(np.array([1,2,3,4,5,6,7,8]))
    v_sim = Simulator('mqvector', 3, seed=42)
    v_sim.set_qs(np.array([1,2,3,4,5,6,7,8]))
    res0 = m_sim.sampling(circ, shots=100, seed=42)
    res1=v_sim.sampling(circ,shots=100, seed=42)
    # print(res0.data)
    # print(res1.data)
    is_equal = (res0.data==res1.data)
    print('test_sampling:', is_equal)
    
def test_channel():
    from cmath import sqrt
    gamma = 0.1
    kmat0 = [[1, 0], [0, sqrt(1 - gamma)]]
    kmat1 = [[0, sqrt(gamma)], [0, 0]]
    import paddle_quantum
    paddle_quantum.set_backend('density_matrix')
    num_qubits = 3
    p_circ = paddle_quantum.ansatz.Circuit(num_qubits)
    p_circ.h(0)
    p_circ.h(1)
    p_circ.cx([0,2])
    p_circ.s(2)
    p_circ.s(1)
    p_circ.t(0)
    p_circ.amplitude_damping(0.1, 2)
    p_circ.phase_damping(0.1, 1)
    p_circ.bit_flip(0.1, 0)
    p_circ.phase_flip(0.1, 2)
    p_circ.bit_phase_flip(0.1, 1)
    p_circ.depolarizing(0.1,0)
    p_circ.bit_flip(0.1, 2)
    # p_circ.pauli_channel([0.01,0.01,0.01],2)
    p_circ.amplitude_damping(0.1, 1)
    init_state = paddle_quantum.state.zero_state(num_qubits)
    final_state = p_circ(init_state)
    p_qs = final_state.numpy()
    
    m_circ = Circuit()
    m_circ += H.on(1)
    m_circ += H.on(2)
    m_circ += X.on(0,2)
    m_circ += S.on(0)
    m_circ += S.on(1)
    m_circ += T.on(2)
    m_circ += AmplitudeDampingChannel(0.1).on(0)
    m_circ += PhaseDampingChannel(0.1).on(1)
    m_circ += BitFlipChannel(0.1).on(2)
    m_circ += PhaseFlipChannel(0.1).on(0)
    m_circ += BitPhaseFlipChannel(0.1).on(1)
    m_circ += DepolarizingChannel(0.1).on(2)
    m_circ += PauliChannel(0.1,0,0).on(0)
    m_circ += KrausChannel('k',[kmat0,kmat1]).on(1)
    m_sim = Simulator('mqmatrix', 3,seed=42)
    m_sim.apply_circuit(m_circ)
    m_qs = m_sim.get_qs()
    # print(p_qs)
    # print()
    # print(m_qs)
    is_equal = np.allclose(p_qs, m_qs)
    print('test_channel:', is_equal)
    
    
def test_hamiltonian():
    ham = Hamiltonian(QubitOperator('X0', 1))
    circ = random_circuit(2, 100)
    
    m_sim = Simulator('mqmatrix', 2)
    m_sim.set_qs(np.array([1,2,3,4]))
    v_sim = Simulator('mqvector', 2)
    v_sim.set_qs(np.array([1,2,3,4]))
    
    m_sim.apply_circuit(circ)
    m_sim.apply_hamiltonian(ham)
    qs0 = m_sim.get_qs()
    v_sim.apply_circuit(circ)
    v_sim.apply_hamiltonian(ham)
    
    vec = v_sim.get_qs()
    qs1 = np.outer(vec, vec.conj())
    print(qs0)
    print()
    print(qs1)
    is_equal = np.allclose(qs0,qs1)
    print('test_hamiltonian:', is_equal)
    
def test_expectation():
    ham = Hamiltonian(QubitOperator('X0 Y2', 0.5) + 0.6 * QubitOperator('X0 Z1'))
    circ = random_circuit(2, 100)
    m_sim = Simulator('mqmatrix', 3)
    m_sim.set_qs(np.array([1,2,3,4,5,6,7,8]))
    v_sim = Simulator('mqvector', 3)
    v_sim.set_qs(np.array([1,2,3,4,5,6,7,8]))
    m_sim.apply_circuit(circ)
    m_ept = m_sim.get_expectation(ham)
    v_sim.apply_circuit(circ)
    v_ept = v_sim.get_expectation(ham)
    # print(m_ept)
    # print(v_ept)
    is_equal = np.allclose(m_ept,v_ept)
    print('test_expectation:', is_equal)
    
def test_reversible_grad():
    ham = Hamiltonian(QubitOperator('X0', 2)+QubitOperator('X1', 1))
    ham1 = Hamiltonian(QubitOperator('Y1', 1))
    circ = Circuit()
    circ += H.on(0)
    circ += H.on(1)
    circ += PhaseShift(2).on(2)
    circ += H.on(3)
    circ += XX('a').on([0,1])
    circ += S.on(3)
    circ += RX({'a':0.2,'b':0.5}).on(1)
    circ += X.on(1,0)
    circ += RY('b').on(0)
    circ += H.on(2,1)
    circ += RZ(1).on(3)
    circ += RZ('b').on(3)
    circ += RX(1).on(2)
    circ2 = Circuit()
    circ2 += RX('c').on(2)
    circ2 += H.on(3,0)
    circ2 += RY('d').on(0)
    circ2 += T.on(1)
    circ2 += RZ('d').on(1)
    circ2 += X.on(0,2)
    circ2 += YY('c').on([2,1])
    circ2 += ZZ('d').on([3,2])
    circ2 = as_encoder(circ2)
    circ = as_ansatz(circ)
    circ = circ2 + circ
    m_sim = Simulator('mqmatrix', 4)
    v_sim = Simulator('mqvector', 4)
    m_grad_ops = m_sim.get_expectation_with_grad([ham,ham1], circ)
    v_grad_ops = v_sim.get_expectation_with_grad([ham,ham1], circ)
    mf, mg1, mg2 = m_grad_ops(np.array([[2,5],[3,0.2]]),np.array([1,2]))
    vf, vg1, vg2 = v_grad_ops(np.array([[2,5],[3,0.2]]),np.array([1,2]))
    is_equal = np.allclose(mf,vf) & np.allclose(mg1,vg1) & np.allclose(mg2,vg2)
    print('test_expectation_with_grad:', is_equal)
    
    # test noise grad
    noise_circ = circ.with_noise(AmplitudeDampingChannel(0))
    noise_grad_ops = m_sim.get_expectation_with_grad([ham,ham1], noise_circ)
    nf, ng1, ng2 = noise_grad_ops(np.array([[2,5],[3,0.2]]),np.array([1,2]))
    n_is_equal = np.allclose(nf,vf) & np.allclose(ng1,vg1) & np.allclose(ng2,vg2)
    print('test_expectation_with_noise_grad:', n_is_equal)
    
if __name__=='__main__':
    # test_gate()
    # test_channel()
    # test_expectation()
    # test_measure()
    # test_sampling()
    test_reversible_grad()
    

    